#!/usr/bin/env python3
# encoding: utf-8 (as per PEP 263)

import sys
from datetime import datetime, timezone
import argparse
import netrc
from INWX.Domrobot import ApiClient, ApiType
from dns import zone, zonefile

def zone_to_records(zone):
    return set(zone.to_text().splitlines())

def zonetext_to_records(zone_text, origin):
    return zone_to_records(zone.from_text(zone_text, origin=origin))

def zonefile_to_records(zone_file, origin):
    return zone_to_records(zone.from_file(zone_file, origin=origin))

def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument(
            "-d",
            "--debug",
            action="store_true",
            help="Enable debug output. Warning: This may output password in plaintext!"
            )
    parser.add_argument(
            "--ote",
            action="store_true",
            help="Use the INWX \"OTE\" testing environment instead of the \"live\" one."
            )
    parser.add_argument(
            "-n",
            "--dry-run",
            action="store_true",
            help="Do not actually save any changes to the zone."
            )
    parser.add_argument(
            "-t",
            "--tfa",
            help="""Supply a 2-factor authentication token. If 2FA is enabled and th\
                    is is not given, you will be asked interactively."""
                    )
    parser.add_argument(
            "-o",
            "--output",
            help="""Output file to write the zone file to. This file is written befo\
                    re any changes are made to the zone contents."""
                    )
    parser.add_argument(
            "-i",
            "--input",
            help="Input file to read the new zone contents from."
            )
    parser.add_argument(
            dest="domain",
            help="The domain name to read/update. Accepted both with and without trailing dot."
            )

    args = parser.parse_args()

    args.domain = args.domain.rstrip('.')
    args.fqdn = args.domain + '.'

    return args

def delete_records(args, api_client, records, origin):
    rrsets_to_delete = zonefile.read_rrsets('\n'.join(records), rdclass=None, origin=origin)

    for rr in rrsets_to_delete:
        if args.debug:
            sys.stderr.write('Querying record: %s\n' % (rr))

        result = api_client.call_api('nameserver.info', {'domain': args.domain, 'type': rr.rdtype.name, 'name': str(rr.name), 'ttl': rr.ttl})
        if result.get('code', 0) != 1000 or args.debug:
            sys.stderr.write('Result for nameserver.info on "%s": %s\n' % (rr, result))
        record_ids = result.get('resData', dict()).get('record', [])
        if not record_ids:
            sys.stderr.write('No existing record found (even though it existed in the pre-calculated diff): %s\n' % (rr))
            continue

        for record_id in record_ids:
            if args.debug:
                sys.stderr.write('%sDeleting record: %s\n' % ('[Simulating] ' if args.dry_run else '', record_id))

            params = {
                    'id': record_id,
                    'testing': True or args.dry_run,
                    }
            result = api_client.call_api('nameserver.deleteRecord', params)
            if result.get('code', 0) != 1000 or args.debug:
                sys.stderr.write('Result for nameserver.deleteRecord on "%s"/id=%d: %s\n' % (rr, record_id, result))

def create_records(args, api_client, records, origin):
    rrsets_to_add = zonefile.read_rrsets('\n'.join(records), rdclass=None, origin=origin)

    for rr in rrsets_to_add:
        if args.debug:
            sys.stderr.write('%sCreating record: %s\n' % ('[Simulating] ' if args.dry_run else '', rr))

        params = {
                'domain': args.domain,
                'type': rr.rdtype.name,
                'name': str(rr.name),
                'ttl': rr.ttl,
                'testing': args.dry_run,
                # value: added later
                # prio: added later if applicable
                }

        # Here comes a really crappy heuristic, because dnspython
        # doesn't convert from_text to typed Record classes (which
        # matters for MX, SRV, etc, because INWX requires their
        # priority field to be given as a separate parameter).
        # I would have expected to use something like hasattr(rr,
        # 'priority'), but alas, we have to check if the first field is
        # a number (and therefore probably a priority value)...
        parts = rr.to_text().split(maxsplit=5)
        if hasattr(rr, 'priority'):
            # Check for a proper 'priority' attribute, just in case support gets added at some point...
            params['prio'] = rr.priority
            value = ' '.join(parts[4:])
        else:
            try:
                # First part of the value is a number => assume it's a priority
                prio = int(parts[4])
                params['prio'] = prio
                value = ' '.join(parts[5:])
            except ValueError:
                # First part of the value is NOT a number => combine the whole value into a string
                value = ' '.join(parts[4:])
        params['content'] = value
        result = api_client.call_api('nameserver.createRecord', params)
        if result.get('code', 0) != 1000 or args.debug:
            sys.stderr.write('Result for nameserver.createRecord on "%s": %s\n' % (rr, result))

def main():
    args = parse_args()

    api_url = ApiClient.API_OTE_URL if args.ote else ApiClient.API_LIVE_URL
    api_host = api_url.split('//')[-1]

    nr = netrc.netrc()
    auth = nr.authenticators(api_host)
    if not auth:
        raise Exception('No authentication credentials found in netrc for machine "%s".' % api_host)
    username, _, password = auth

    api_client = ApiClient(api_url=api_url, debug_mode=args.debug, api_type=ApiType.JSON_RPC)

    params = {'lang': 'en', 'user': username, 'pass': password}
    login_result = api_client.call_api('account.login', params)

    tfa_token = args.tfa
    if not tfa_token:
        tfa_token = input('2FA token: ')
    api_client.call_api('account.unlock', {'tan': tfa_token})

    # get current zone contents
    export = api_client.call_api(api_method='nameserver.export', method_params={'domain': args.domain})
    current_zone_content = export['resData']['export']
    current_zone_records = zonetext_to_records(current_zone_content, args.fqdn)

    # if requested, write current zone contents to file
    if args.output:
        if args.debug:
            sys.stderr.write('Writing zone to "%s"\n' % args.output)
        with open(args.output, 'w') as output_file:
            output_file.write('; Exported by inwx-sync-zonefile via the INWX API on %s\n' % datetime.now(timezone.utc).strftime('%F %T %Z'))
            output_file.write('$ORIGIN %s\n' % args.fqdn)
            for record in sorted(current_zone_records):
                output_file.write('%s\n' % record)

    # if requested, load new zone contents from file
    if args.input:
        if args.debug:
            sys.stderr.write('Reading zone from "%s"\n' % args.input)
        with open(args.input, 'r') as input_file:
            new_zone_records = zonefile_to_records(input_file, args.fqdn)
            delete_records(args, api_client, current_zone_records - new_zone_records, origin=args.fqdn)
            create_records(args, api_client, new_zone_records - current_zone_records, origin=args.fqdn)

if __name__ == '__main__':
    main()
